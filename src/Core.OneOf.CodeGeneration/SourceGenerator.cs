// -----------------------------------------------------------------------
// <copyright file="SourceGenerator.cs" company="Altemiq">
// Copyright (c) Altemiq. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Altemiq.OneOf.CodeGeneration;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// The source generator.
/// </summary>
[Generator]
public partial class SourceGenerator : ISourceGenerator
{
    private const string OneOf = nameof(OneOf);
    private const string TTypeParameter = "T";
    private const string ResultsTypeParameter = TTypeParameter + "Result";
    private const string IndexPropertyName = "Index";
    private const string IndexVariableName = "index";
    private const string ValuePropertyName = "Value";
    private const string ValueVariableName = "value";
    private const string TVariableName = "t";
    private const string LeftVariableName = "left";
    private const string RightVariableName = "right";
    private const string OtherVariableName = "other";
    private const string ProviderParameterName = "provider";

    private const string ExceptionVariableName = "exception";
    private const string RemainderVariableName = "remainder";
    private const string ObjVariableName = "obj";
    private const string OVariableName = "o";

    private const string TripleSlash = "///";
    private const string Period = ".";
    private const string Space = " ";
    private const string NewLine = @"
";

    private static AttributeSyntax? generatedCodeAttribute;
    private static AttributeSyntax? compilerGeneratedAttribute;

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        const int Count = 10;

        for (var i = 0; i < Count; i++)
        {
            Add(GenerateOneOfGeneric(i + 1), ref context);
        }

        Add(GenerateOneOf(Count), ref context);

        static void Add((string Name, MemberDeclarationSyntax Declaration) member, ref GeneratorExecutionContext context)
        {
            var sourceText = InNamespace(member.Declaration).NormalizeWhitespace().GetText(System.Text.Encoding.UTF8);
            context.AddSource(member.Name + ".cs", sourceText);
        }

        static BaseNamespaceDeclarationSyntax InNamespace(MemberDeclarationSyntax member)
        {
            return FileScopedNamespaceDeclaration(ParseName("Altemiq"))
                .AddMembers(member)
                .WithLeadingTrivia(TriviaList(Comment("// <autogenerated />")));
        }
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        // this is required to be implemented
    }

    private static IEnumerable<string> GetTypeParameterNames(int count) => Enumerable.Range(0, count).Select(GetTypeParameterName);

    private static string GetTypeParameterName(int number) => GetName(TTypeParameter, number);

    private static string GetName(string name, int number) => FormattableString.Invariant($"{name}{number}");

    private static IEnumerable<SyntaxNodeOrToken> Join<TNode>(IEnumerable<TNode> source)
        where TNode : SyntaxNode
    {
        var enumerator = source.GetEnumerator();
        if (enumerator.MoveNext())
        {
            yield return enumerator.Current;
        }

        while (enumerator.MoveNext())
        {
            yield return Token(SyntaxKind.CommaToken);
            yield return enumerator.Current;
        }
    }

    private static AttributeSyntax GetGeneratedCodeAttribute()
    {
        return generatedCodeAttribute ??= GetGeneratedCodeAttributeCore();

        static AttributeSyntax GetGeneratedCodeAttributeCore()
        {
            var assembly = new System.Reflection.AssemblyName(typeof(SourceGenerator).Assembly.FullName);
            return
                Attribute(
                    GetQualifiedName(typeof(System.CodeDom.Compiler.GeneratedCodeAttribute)))
                .WithArgumentList(
                    AttributeArgumentList(
                        SeparatedList(
                            new[]
                            {
                                AttributeArgument(
                                    LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        Literal(assembly.Name))),
                                AttributeArgument(
                                    LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        Literal(assembly.Version.ToString()))),
                            })));
        }
    }

    private static AttributeSyntax GetCompilerGeneratedAttribute()
    {
        return compilerGeneratedAttribute ??= GetCompilerGeneratedAttributeCore();

        static AttributeSyntax GetCompilerGeneratedAttributeCore()
        {
            return
                Attribute(
                    GetQualifiedName(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute)));
        }
    }

    private static NameSyntax GetQualifiedName(Type type)
    {
        var enumerator = GetNames(type).GetEnumerator();
        _ = enumerator.MoveNext();

        NameSyntax name = enumerator.Current;
        while (enumerator.MoveNext())
        {
            name = QualifiedName(name, enumerator.Current);
        }

        return name;
    }

    private static IEnumerable<IdentifierNameSyntax> GetNames(Type type)
    {
        return type.FullName.Split('.').Select(RemoveAttribute).Select(IdentifierName);

        static string RemoveAttribute(string name)
        {
            return name.EndsWith(nameof(Attribute), StringComparison.Ordinal)
                ? name[..^nameof(Attribute).Length]
                : name;
        }
    }
}